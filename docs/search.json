[
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Here I will list some of the projects I have worked on.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIdealista: case in vendita a Malaga\n\n\n\n\n\n\n\n\n\n\n\nDec 17, 2024\n\n\nErik De Luca\n\n\n\n\n\n\n\n\n\n\n\n\nMIPC\n\n\n\n\n\nInternational competition for the best portfolio for a fund plan. \n\n\n\n\n\nOct 15, 2023\n\n\nErik De Luca\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html",
    "title": "MIPC",
    "section": "",
    "text": "My aim was to find the best weights that could be used by a pension fund. The portfolio is composed by REITS, Commodities, CAT BOND, Dividends, Short term bonds, Cash and Inflation linked."
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#import-data",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#import-data",
    "title": "MIPC",
    "section": "Import data",
    "text": "Import data\nI built a dataset with tickers, categories and the initial weights of the portfolio.\n\n\nCode\ndetailPortfolio =\n  tibble(\n    tickerList = c(\n      \"SPG\",      # REITS\n      \"OHI\",\n      \"CCOM.TO\",      # Commodities\n      \"DBC\",\n      \"FCX\",\n      \"KSM-F6.TA\",\n      \"0P0001MN8G.F\",      # CAT BOND\n      \"CDZ.TO\",      # dividend\n      \"NOBL\",\n      \"NSRGY\",\n      \"CNI\",\n      \"WFAFY\",\n      \"UU.L\",\n      \"KO\",\n      \"NVS\",\n      \"NVDA\", # nvidia no dividendi\n      # \"SHY\",  # short term bond -- in truth they are etfs that reproduce the trend\n      # \"VGSH\",\n      \"SPTS\",\n      \"IBGS.AS\",\n      \"6C=F\",      # cash -- I placed a Canadian dollar future to represent liquidity\n      \"XGIU.MI\"     # Inflation linked\n    ),\n    category = c(\n      rep(\"REITS\",2),\n      rep(\"Commodities\",4),\n      rep(\"CAT BOND\",1),\n      rep(\"Dividends\",9),\n      rep(\"Short term bonds\",2),\n      rep(\"Cash\",1), \n      rep(\"Inflation linked\",1) \n    ),\n    weight = c(\n      .08,\n      .06,\n      .046,\n      # comodities\n      .009,\n      .01,\n      .057,\n      .07,\n      # cat bond\n      .02,\n      # div\n      .06,\n      .02,\n      .01,\n      .017,\n      .005,\n      .005,\n      .05,\n      .023,\n      # .07,\n      # .07,\n      .05,\n      .128,\n      .15,\n      # .00,\n      .13\n    )\n  )\ndetailPortfolio |&gt; \n  summarise(\n    across(weight, sum, na.rm = TRUE),\n    .by = category\n  ) |&gt; \n  gt() |&gt; \n  fmt_percent(vars(weight), decimals = 1)\n\n\n\n\n\n\n\n\ncategory\nweight\n\n\n\n\nREITS\n14.0%\n\n\nCommodities\n12.2%\n\n\nCAT BOND\n7.0%\n\n\nDividends\n21.0%\n\n\nShort term bonds\n17.8%\n\n\nCash\n15.0%\n\n\nInflation linked\n13.0%\n\n\n\n\n\n\n\n\nFixed Base Indices\nImport data from Yahoo Finance for the last 5 years and construct the portfolio without the weights of each stock.\n\n\nCode\nstockData = lapply(detailPortfolio$tickerList,\n                     getSymbols,\n                       src = \"yahoo\",\n                       from = as.Date(\"2018-09-30\"),\n                       to = as.Date(\"2023-09-29\"),\n                       auto.assign = F\n                     )\n\n# fix tickets that have changed name during import\ndetailPortfolio$tickerList[detailPortfolio$tickerList == \"KSM-F6.TA\"] = \"KSM.F6.TA\"\ndetailPortfolio$tickerList[detailPortfolio$tickerList == \"6C=F\"] = \"X6C\"\n\n# compact the different lists\nnominalPortfolio = do.call(merge,stockData) %&gt;% \n  na.omit\n\n# the CAT BOND is volume-free\nnominalPortfolio$X0P0001MN8G.F.Volume = 1\n\nfor(i in 1:nrow(detailPortfolio))\n{\n  columnSelect = (!names(nominalPortfolio) %like% \"Volume\") & names(nominalPortfolio) %like% detailPortfolio$tickerList[i]\n  nominalPortfolio[,columnSelect] = nominalPortfolio[,columnSelect] / rep(coredata(nominalPortfolio[1,columnSelect])[1],5) \n}\n\nas_tibble(nominalPortfolio)\n\n\n\n  \n\n\n\n\n\nCode\ngrafico = highchart(type = \"stock\")\nfor(i in 1:nrow(detailPortfolio))\n  grafico = hc_add_series(grafico, \n                          Cl(nominalPortfolio[,names(nominalPortfolio) %like% detailPortfolio$tickerList[i]]),\n                          name = detailPortfolio$tickerList[i])\ngrafico\n\n\n\n\n\n\n\n\nStock performance in the portfolio\nI add the initial portfolio weights.\n\n\nCode\nportfolio = nominalPortfolio\n\nfor(i in 1:nrow(detailPortfolio))\n{\n  columnSelect = (!names(portfolio) %like% \"Volume\") & names(portfolio) %like% detailPortfolio$tickerList[i]\n  portfolio[,columnSelect] = coredata(nominalPortfolio[,columnSelect]) * detailPortfolio$weight[i] \n}\n\nas_tibble(portfolio)\n\n\n\n  \n\n\n\n\n\nCode\ngrafico = highchart(type = \"stock\")\nfor(i in 1:nrow(detailPortfolio))\n  \n  grafico = hc_add_series(grafico, \n                          Cl(portfolio[,names(portfolio) %like% detailPortfolio$tickerList[i]]),\n                          name = detailPortfolio$tickerList[i]) \ngrafico\n\n\n\n\n\n\n\n\nPortfolio Creation\nI create the portfolio by adding up the indices of the stocks multiplied by their weights. This gives the overall performance of the portfolio.\n\n\nCode\ncolumnNames = c(\"Open\", \"High\", \"Low\", \"Close\", \"Volume\", \"Adjusted\")\nmyPortfolio = matrix(NA, nrow(portfolio),ncol = length(columnNames))\n\nfor(i in 1:length(columnNames))\n{\n  columnSelect = names(portfolio) %like% columnNames[i]\n  myPortfolio[,i] = sapply(1:nrow(portfolio), function(r) sum(coredata(portfolio[r,columnSelect])))  \n}\n\ncolnames(myPortfolio) = paste(\"Portfolio\", columnNames, sep = \".\")\nmyPortfolio = xts(myPortfolio, order.by = index(portfolio))\n\nas_tibble(myPortfolio)\n\n\n\n  \n\n\n\n\n\nCode\np = myPortfolio %&gt;% \n  fortify() %&gt;% \n  ggplot(aes(x = Index, y = Portfolio.Open)) + \n  geom_smooth(method = \"gam\",\n              formula = formula(y ~ s(x)),\n              fill = pal[5],\n              aes(color = pal[5]),\n              alpha = .3) +\n  geom_line(color = pal[3]) +\n  geom_pointrange(aes(ymin = Portfolio.Low, \n                    ymax = Portfolio.High), \n              alpha = 0.22,\n              fill =  'turquoise1',\n              size = .1) +\n  # geom_col(aes(y = Portfolio.Volume),inherit.aes = F) +\n  xlab(\"\") +\n  ylab(\"\") +\n  scale_y_continuous(labels = function(x) scales::percent(x-1)) +\n  scale_color_manual(values = pal[5], labels = \"Prediction of portfolio trends using splines\") +\n  theme(legend.position = \"bottom\",\n        legend.title = element_blank())\n\np\n\n\n\n\n\n\n\n\n\nCode\n# ggplotly(p)"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#decomposition-historical-series",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#decomposition-historical-series",
    "title": "MIPC",
    "section": "Decomposition historical series",
    "text": "Decomposition historical series\nI decompose the historical series to display its different components.\n\n\nCode\npfDecomposto = decompose(ts(myPortfolio$Portfolio.Open %&gt;% as.vector(),\n                            start = c(2022, 9, 29),\n                            # end = c(2023, 09, 28),\n                            frequency = 7))\n# plot(pfDecomposto)\np = tibble(Dates = seq(as.Date(\"2022-09-29\"),\n                   length = length(pfDecomposto$x),\n                   by =  \"days\"),\n       Serie = pfDecomposto$x %&gt;% coredata(),\n       Seasonal = pfDecomposto$seasonal %&gt;% coredata(),\n       Trend = pfDecomposto$trend %&gt;% coredata(),\n       Random = pfDecomposto$random %&gt;% coredata()) %&gt;% \n  gather(key = \"Type\", -Dates, value = \"y\") %&gt;% \n  ggplot(aes(x = Dates, y = y)) + \n    geom_line() +\n    facet_grid(rows = vars(Type), \n               scales = \"free_y\") +\n  ylab(\"\")  +\n  scale_x_date(date_breaks = \"1 month\",\n               date_labels = \"%b\")\n\nggplotly(p, dynamicTicks = TRUE) %&gt;%\n  # rangeslider() \n  plotly::layout(hovermode = \"x\")"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#optimisation",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#optimisation",
    "title": "MIPC",
    "section": "Optimisation",
    "text": "Optimisation\nThe current portfolio has these indices, our goal now is to optimise the portfolio to maximise the sharpe rato index, i.e. to maximise the portfolio’s return while minimising its risk.\n\n\nCode\nnominalPortfolioAdj = nominalPortfolio[,names(nominalPortfolio) %like% \"Adjusted\"] %&gt;%\n  CalculateReturns() %&gt;% \n  to.yearly.contributions() %&gt;% \n  na.omit()\n\nweight = detailPortfolio$weight\n\nnominalPortfolioAdj = nominalPortfolioAdj[,names(nominalPortfolioAdj) != \"Portfolio Return\"]\n\nmean_ret = colMeans(nominalPortfolioAdj)\n\ncov_mat = nominalPortfolio[,names(nominalPortfolio) %like% \"Adjusted\"] %&gt;%\n  CalculateReturns() %&gt;% \n  to.quarterly.contributions() %&gt;% \n  na.omit() %&gt;% \n  cov()\n\n# solo quando i volumi non sono degeneri\n\nreturn3mesi = nominalPortfolio[,!names(nominalPortfolio) %like% \"Volume\"] %&gt;%\n  CalculateReturns() %&gt;%\n  to.period.contributions(\"quarters\") %&gt;%\n  na.omit()\n\nvar3m = VaR(R = return3mesi[,names(return3mesi) %like% \"Adjusted\"],\n            method = \"historical\",\n            portfolio_method = \"component\",\n            weights = weight)\n\nport_risk = var3m$hVaR\n\ncov_mat = cov_mat[rownames(cov_mat) != \"Portfolio Return\",\n                  colnames(cov_mat) != \"Portfolio Return\"]\n\nport_returns = sum(mean_ret * weight)\n\nport_risk = sqrt(t(weight) %*% (cov_mat %*% weight))\n\nsharpe_ratio = port_returns/port_risk\n\ntibble(\"Return\" = port_returns,\n       \"Risk\" = port_risk,\n       \"VaR a 3 mesi\" = var3m$hVaR,\n       \"Sharpe ratio\" = sharpe_ratio) |&gt; \n  gt() |&gt; \n  fmt_percent(columns = 1:3) |&gt; \n  fmt_number(columns = 4, decimals = 2)\n\n\n\n\n\n\n\n\nReturn\nRisk\nVaR a 3 mesi\nSharpe ratio\n\n\n\n\n6.77%\n2.28%\n−0.96%\n2.98\n\n\n\n\n\n\n\n\nMonteCarlo Simulation\nA simulation will be carried out using the MonteCarlo method where the experiment will be repeated by randomly extracting the weights, thus finding the best portfolio combination. In this case, the experiment will be repeated 5000 times but the portfolio weights will not be completely random, they will vary around the values we preset.\n\n\nCode\nset.seed(1)\nnum_port = 5000\n\n# Creating a matrix to store the weights\nall_wts = matrix(nrow = num_port,\n                  ncol = nrow(detailPortfolio))\n\n# Creating an empty vector to store\n# Portfolio returns\nport_returns = vector('numeric', length = num_port)\n\n# Creating an empty vector to store\n# Portfolio Standard deviation\nport_risk = vector('numeric', length = num_port)\n\n# Creating an empty vector to store\n# Portfolio Sharpe Ratio\nsharpe_ratio = vector('numeric', length = num_port)\n\nfor (i in seq_along(port_returns)) {\n  precisione = 0.9\n  wts = sapply(1:length(weight), function(i) runif(1,precisione * weight[i], (2 - precisione) * weight[i]))\n  # wts = runif(length(tickerList))\n  wts = wts/sum(wts)\n  \n  # Storing weight in the matrix\n  all_wts[i,] = wts\n  \n  # Portfolio returns\n  \n  port_ret = sum(wts * mean_ret)\n  # port_ret &lt;- ((port_ret + 1)^252) - 1\n  \n  # Storing Portfolio Returns values\n  port_returns[i] = port_ret\n  \n  \n  # Creating and storing portfolio risk\n  port_sd = sqrt(t(wts) %*% (cov_mat  %*% wts))\n\n  # Più preciso ma ci mette troppo  \n  # port_sd = VaR(\n  #   R = return3mesi[, names(return3mesi) %like% \"Adjusted\"],\n  #   method = \"historical\",\n  #   portfolio_method = \"component\",\n  #   weights = wts\n  # )$hVaR\n\n  port_risk[i] = port_sd\n  \n  \n  # Creating and storing Portfolio Sharpe Ratios\n  # Assuming 0% Risk free rate\n  sr = port_ret/port_sd\n  sharpe_ratio[i] = sr\n}\n\n\n\n\nPortfolio weights\nThe weights assigned by the portfolio with the highest sharpe ratio are shown in the interactive plot below.\n\n\nCode\n# Storing the values in the table\nportfolio_values = tibble(Return = port_returns,\n                  Risk = port_risk,\n                  SharpeRatio = sharpe_ratio)\n\n\n# Converting matrix to a tibble and changing column names\nall_wts = all_wts %&gt;%\n  data.frame() %&gt;%\n  tibble\ncolnames(all_wts) = detailPortfolio$tickerList\n\n# Combing all the values together\nportfolio_values = tibble(cbind(all_wts, portfolio_values))\ncolnames(portfolio_values)[1:nrow(detailPortfolio)] = detailPortfolio$tickerList\n\nmin_var = portfolio_values[which.min(portfolio_values$Risk),]\nmax_sr = portfolio_values[which.max(portfolio_values$SharpeRatio),]\n\n# weightOLD = weight\nweight = max_sr[,1:nrow(detailPortfolio)] %&gt;% \n  as.numeric() %&gt;% \n  round(4) \n\n# con l'arrotondamento potrebbe non fare 1 e lo calibro con il primo titolo, ciò non influenzerà significativamente sullo scostamento del portafoglio\nweight[1] = weight[1] + 1 - sum(weight)\n\n# max_sr %&gt;% \n#   t() %&gt;%\n#   data.frame()\n\np = max_sr %&gt;%\n  gather(detailPortfolio$tickerList, key = Asset,\n         value = Weights) %&gt;%\n  cbind(Category = factor(detailPortfolio$category)) %&gt;% \n  mutate(Asset = Asset %&gt;%\n           as.factor() %&gt;% \n           fct_reorder(Weights),\n         Percentage = str_c(round(Weights*100,2), \"%\")) %&gt;%\n  ggplot(aes(x = Asset,\n             y = Weights,\n             fill = Category,\n             label = Percentage)) +\n  geom_bar(stat = 'identity') +\n  geom_label(nudge_y = .01, size = 3) +\n  theme_minimal() +\n  labs(x = 'Tickers',\n       y = 'Weights',\n       title = \"Weights of the portfolio tangent to the efficient frontier\") +\n  scale_y_continuous(labels = scales::percent) +\n  guides(fill = guide_legend(override.aes = aes(label = \"\"))) + \n  theme(legend.position = \"bottom\") +\n  coord_flip()\n\nggplotly(p)\n\n\n\n\n\n\n\n\nEfficient frontier\nThe graph below shows the values of the portfolios created during the optimisation process. The red dot represents the portfolio with the highest sharpe ratio.\n\n\nCode\np = portfolio_values %&gt;%\n  ggplot(aes(x = Risk, y = Return, color = SharpeRatio)) +\n  geom_point() +\n  theme_classic() +\n  scale_y_continuous(labels = scales::percent) +\n  scale_x_continuous(labels = scales::percent) +\n  labs(x = 'Annual risk',\n       y = 'Annual return',\n       title = \"Portfolio optimization and efficient frontier\") +\n  geom_point(aes(x = Risk,\n                 y = Return),\n             data = max_sr,\n             color = 'darkred') \n\nggplotly(p)"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#optimised-portfolio",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#optimised-portfolio",
    "title": "MIPC",
    "section": "Optimised portfolio",
    "text": "Optimised portfolio\n\n\nCode\n# I recreate the portfolio with the new weights\nportfolio = nominalPortfolio\n\nfor(i in 1:nrow(detailPortfolio))\n{\n  columnSelect = (!names(portfolio) %like% \"Volume\") & names(portfolio) %like% detailPortfolio$tickerList[i]\n  portfolio[,columnSelect] = coredata(nominalPortfolio[,columnSelect]) * weight[i] \n}\n\ncolumnNames = c(\"Open\", \"High\", \"Low\", \"Close\", \"Volume\", \"Adjusted\")\nmyPortfolio = matrix(NA, nrow(portfolio),ncol = length(columnNames))\n\nfor(i in 1:length(columnNames))\n{\n  columnSelect = names(portfolio) %like% columnNames[i]\n  myPortfolio[,i] = sapply(1:nrow(portfolio), function(r) sum(coredata(portfolio[r,columnSelect])))  \n}\n\ncolnames(myPortfolio) = paste(\"Portfolio\", columnNames, sep = \".\")\nmyPortfolio = xts(myPortfolio, order.by = index(portfolio)) \n\nmyPortfolio %&gt;% \n  fortify() %&gt;% \n  mutate(across(starts_with(\"Portfolio\"), \\(x) x/dplyr::first(x))) %&gt;%\n  ggplot(aes(x = Index, y = Portfolio.Open)) + \n  geom_smooth(method = \"gam\",\n              formula = formula(y ~ s(x)),\n              fill = pal[5],\n              aes(color = pal[5]),\n              alpha = .3) +\n  geom_line(color = pal[3]) +\n  geom_pointrange(aes(ymin = Portfolio.Low, \n                      ymax = Portfolio.High), \n              alpha = 0.22,\n              fill = 'turquoise1',\n              size = .1) +\n  # geom_col(aes(y = Portfolio.Volume),inherit.aes = F) +\n  xlab(\"\") +\n  ylab(\"\") +\n  scale_y_continuous(labels = function(x) scales::percent(x)) +\n  scale_color_manual(values = pal[5], labels = \"Prediction of portfolio trends using splines\") +\n  theme(legend.position = \"bottom\",\n        legend.title = element_blank())"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#var-value-at-risk",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#var-value-at-risk",
    "title": "MIPC",
    "section": "VaR: Value at Risk",
    "text": "VaR: Value at Risk\nIn the following graph, the different securities are shown with their yield, their variance on the abscissa and are coloured according to their coefficient of variation. This graph helps in the choice of initial weights (pre-optimisation) as it is easy to visualise those that perform best.\n\n\nCode\nreturnTicker = \n  map_dfc(\n    detailPortfolio$tickerList,\n    ~dailyReturn(Cl(nominalPortfolio[,names(portfolio) %like% .x]))\n  )\n\n\nNew names:\n• `daily.returns` -&gt; `daily.returns...1`\n• `daily.returns` -&gt; `daily.returns...2`\n• `daily.returns` -&gt; `daily.returns...3`\n• `daily.returns` -&gt; `daily.returns...4`\n• `daily.returns` -&gt; `daily.returns...5`\n• `daily.returns` -&gt; `daily.returns...6`\n• `daily.returns` -&gt; `daily.returns...7`\n• `daily.returns` -&gt; `daily.returns...8`\n• `daily.returns` -&gt; `daily.returns...9`\n• `daily.returns` -&gt; `daily.returns...10`\n• `daily.returns` -&gt; `daily.returns...11`\n• `daily.returns` -&gt; `daily.returns...12`\n• `daily.returns` -&gt; `daily.returns...13`\n• `daily.returns` -&gt; `daily.returns...14`\n• `daily.returns` -&gt; `daily.returns...15`\n• `daily.returns` -&gt; `daily.returns...16`\n• `daily.returns` -&gt; `daily.returns...17`\n• `daily.returns` -&gt; `daily.returns...18`\n• `daily.returns` -&gt; `daily.returns...19`\n• `daily.returns` -&gt; `daily.returns...20`\n\n\nCode\n# for(i in 1:nrow(detailPortfolio))\n#   returnTicker = cbind(returnTicker,dailyReturn(Cl(nominalPortfolio[,names(portfolio) %like% detailPortfolio$tickerList[i]])))\ncolnames(returnTicker) = detailPortfolio$tickerList\n\nreturnTickerIndici = returnTicker %&gt;% \n  as.tibble() %&gt;%\n  summarise_all(sum) %&gt;% \n  pivot_longer(1:nrow(detailPortfolio), names_to = \"Titoli\", values_to = \"Rendimento\")  %&gt;% \n  add_column(returnTicker %&gt;%\n               as.tibble() %&gt;%\n               summarise_all(sd) %&gt;%\n               pivot_longer(1:nrow(detailPortfolio), names_to = \"Titoli\", values_to = \"Varianza\") %&gt;% \n               dplyr::select(Varianza)\n             ) %&gt;% \n  mutate(Variazione = ifelse(round(Rendimento, 2) != 0,\n                             Varianza/abs(Rendimento),\n                             1)) \n\nhValMin = 1.8 # giocando con questo parametro si cambia l'asse delle y modificando la distanza dei punti estremi ai punti centrali\nhValMax = 1\n\np = returnTickerIndici %&gt;%\n  mutate(quantili = punif(Rendimento,\n                       min = hValMin * min(Rendimento), # se non metto hvalmin il min di Rendimento vale 0 e di conseguenza il log tende a meno infinito\n                       max = hValMax * max(Rendimento),\n                       log.p = T), \n    across(where(is.numeric), \\(x) round(x, 4)),\n    # across(vars(Rendimento), )\n  ) |&gt; \n  ggplot(aes(y = quantili,\n             x = Varianza,\n             color = Variazione,\n             label = Titoli,\n             z = Rendimento # serve solo per l'etichetta nel grafico interattivo\n             )) +\n  geom_point(size = 1.5) + \n  scale_color_distiller(palette = \"RdYlGn\", direction = -1) +\n  scale_x_log10(labels = scales::percent_format(accuracy = .2),\n                breaks = scales::breaks_log(n = 10, base = 10)) +\n  scale_y_continuous(labels = function(x) scales::percent(qunif(x,\n                                                                min = hValMin * min(returnTickerIndici$Rendimento),\n                                                                max = hValMax * max(returnTickerIndici$Rendimento),\n                                                                log.p = T), # associo i valori originali invertendo la funzione di ripartizione\n                                                          scale = 1),\n                     breaks = scales::pretty_breaks(10)) +\n  labs(x = \"Variation\", y = \"Return\", color = \"Coefficient \\nof variation\") +\n  theme(legend.position = \"right\", \n        legend.title.align = 0) \n\n\nggplotly(p, tooltip = c(\"z\", \"x\", \"color\", \"label\"))\n\n\n\n\n\n\n\n\nCode\nreturn3mesi = nominalPortfolio %&gt;% \n  CalculateReturns %&gt;% \n  to.period.contributions(\"quarters\")\n\n\nweight_max_sr = max_sr %&gt;% \n      t() %&gt;% \n      head(nrow(detailPortfolio)) %&gt;% \n      as.vector()\n\nVaR(return3mesi[,names(return3mesi) %like% \"Open\"],\n    method = \"historical\",\n    weights = weight_max_sr,\n    portfolio_method = \"marginal\") %&gt;% \n  pivot_longer(1:length(weight_max_sr)+1, names_to = \"Titoli\", values_to = \"VaR\") %&gt;% \n  mutate(VaR = round(VaR *100, 2)) %&gt;% \n  ggplot(aes(x = Titoli, y = VaR, fill = VaR)) +\n  geom_col() +\n  geom_hline(aes(yintercept = PortfolioVaR), color = \"orchid\") +\n  coord_flip() + \n  scale_fill_distiller(palette = \"RdYlGn\", direction = 1) +\n  theme(legend.position = \"none\") +\n  scale_x_discrete(labels = function(x) str_remove(x,\".Open\")) +\n  labs(\n    x = \"\",\n    title = \"Value at Risk of the single securities\",\n    ) +\n  scale_y_continuous(labels = scales::percent_format(),\n                     breaks = scales::pretty_breaks(8))\n\n\n\n\n\n\n\n\n\nThe following histogram shows the simulation of 1000000 samples taken from a normal of mean equal to the portfolio return on a four-monthly basis and the variance equal to the portfolio variance on a four-monthly basis.\n\n\nCode\nalpha = 0.005\n\nmedia = sapply(1:nrow(return3mesi), function(i) sum(return3mesi[i,names(nominalPortfolio) %like% \"Adjusted\"] * weight_max_sr)) %&gt;% mean(na.rm = T)\n\nvarianza = sapply(1:nrow(return3mesi), function(i) sum(return3mesi[i,names(nominalPortfolio) %like% \"Adjusted\"] * weight_max_sr)) %&gt;% sd(na.rm = T)\n\nset.seed(1)\ndf = data.frame(x = rnorm(1E6, media, varianza))\nggplot(df, aes(x, ..density..)) +\n  geom_histogram(color = \"violet\",\n                 fill = \"orchid1\",\n                 alpha = .5,\n                 bins = 30) +\n  geom_density(color = \"aquamarine\") +\n  geom_vline(xintercept = quantile(df$x, probs = alpha),\n             color = \"aquamarine2\") +\n  annotate('text',\n           x = quantile(df$x, probs = alpha),\n           y = 0.01,\n           color = \"aquamarine4\",\n           label = paste(\"VaR = \",df$x %&gt;% \n                           quantile(probs = alpha) %&gt;% \n                           round(4))) +\n  scale_y_continuous(labels = NULL) +\n  labs(\n    x = \"\",\n    y = \"\",\n    title = \"Value at Risk\",\n    )"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#correlation",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#correlation",
    "title": "MIPC",
    "section": "Correlation",
    "text": "Correlation\nThe correlation chart is useful to see the diversification of the portfolio.The plot is interactive, so you can zoom in and out to see the details.\n\n\nCode\ncorrelazione = return3mesi[,names(return3mesi) %like% \"Adjusted\"] %&gt;% \n  na.omit %&gt;% \n  cor\n\ncolnames(correlazione) = stringr::str_remove(colnames(correlazione),\".Adjusted\")\nrownames(correlazione) = stringr::str_remove(colnames(correlazione),\".Adjusted\")\n\n\n# categories = levels(factor(detailPortfolio$category))\n# pal[which(detailPortfolio$category[detailPortfolio$tickerList == \"XGIU.MI\"] == categories)]\n\n\n# Funzione personalizzata per etichette colorate\ncolor_labels = function(labels, colors) {\n  mapply(function(label, color) {\n    as.expression(bquote(bold(.(color)(.(label)))))\n  }, labels, colors, SIMPLIFY = FALSE)\n}\n\np = correlazione %&gt;% \n  reshape2::melt() %&gt;% \n  ggplot(aes(x=Var1, y=Var2, fill = value, color = value)) + \n  geom_tile() +\n  scale_fill_distiller(name = \"Correlation\",\n                       palette = \"RdYlGn\",\n                       direction = 1) +\n  # geom_label(aes(label = round(value,2)), size =2,label.size = 0) +\n  scale_x_discrete(limits = rev(rownames(correlazione))) +\n  # scale_color_identity() +  # Imposta scale_color_identity per rimuovere il mapping del colore\n  guides(color = guide_legend(override.aes = list(color = NULL))) +  # Imposta color su NULL per nasconderlo\n  theme(axis.title = element_blank(),\n        axis.text.x = element_text(angle = 30,vjust = .95, hjust = .95))\n\nggplotly(p)\n\n\n\n\n\n\nCode\n# map_chr(detailPortfolio$tickerList,~ palette.colors(length(levels(factor(detailPortfolio$category))),\"Dark2\")[as.numeric(labels(factor(detailPortfolio$category,ordered = T)[detailPortfolio$tickerList == .x]))])\n# \n# sapply(detailPortfolio$tickerList,function(x) as.numeric(labels(factor(detailPortfolio$category,ordered = T)[detailPortfolio$tickerList == x])))"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\nCode\n1 + 1\n\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Erik De Luca",
    "section": "",
    "text": "Hello! I’m Erik De Luca, an actuary with a passion for data science, always seeking new ways to transform complex numbers and data into comprehensible stories and practical solutions. With a background in statistics and actuarial techniques, I have a keen interest in quantitative finance and portfolio optimization. When not immersed in numbers, I indulge in travel, craft beer brewing, and judo. Welcome to my corner of the web!"
  },
  {
    "objectID": "projects/2024-12-17_Idealista_API/index.html",
    "href": "projects/2024-12-17_Idealista_API/index.html",
    "title": "Idealista: case in vendita a Malaga",
    "section": "",
    "text": "The aim of this project is to download all the ads of houses for sale in Trieste from the Idealista website and conduct a preliminary analysis of the data. Moreover, we will create a map with the location of the houses for sale, to get an idea of the distribution of the ads and their prices in the city."
  },
  {
    "objectID": "projects/2024-12-17_Idealista_API/index.html#get-the-data",
    "href": "projects/2024-12-17_Idealista_API/index.html#get-the-data",
    "title": "Idealista: case in vendita a Malaga",
    "section": "Get the Data",
    "text": "Get the Data\n\n\nCode\nlibrerie = c(\n  \"jsonlite\",\n  \"httr\", # for the API\n  \"scales\",\n  \"ggplot2\",\n  \"leaflet\", # for the map\n  \"RColorBrewer\", # for the map\n  # \"reticulate\", \n  \"tidyverse\",\n  \"plotly\",\n  \"randomForest\" # for na.roughfix\n)\n\nInstall_And_Load &lt;- function(packages) {\n  k &lt;- packages[!(packages %in% installed.packages()[,\"Package\"])];\n  if(length(k))\n  {install.packages(k, repos='https://cran.rstudio.com/');}\n\n  for(package_name in packages)\n  {library(package_name,character.only=TRUE, quietly = TRUE);}\n}\n\n# the tidyverse functions are used instead of the others in case of same name for two functions\n# conflicted::conflict_prefer_all(\"tidyverse\")\nconflicted::conflict_prefer_all(\"dplyr\")\nconflicted::conflict_prefer_all(\"ggplot2\")\n\n\nInstall_And_Load(librerie)\n\n\nTo access the idealista APIs we need to obtain the credentials. You can get them by registering on the idealista website.\n\n\nCode\n# parametri in input\n\n# nuove credenziali\n\nconsumer_key = readRDS(\"keys/consumer_key.rds\")\nconsumer_secret = readRDS(\"keys/consumer_secret.rds\")\n# saveRDS(consumer_key, file = \"keys/consumer_key.rds\")\n# saveRDS(consumer_secret, file = \"keys/consumer_secret.rds\")\n\n\n#Use basic authentication\nsecret &lt;- jsonlite::base64_enc(paste(consumer_key, consumer_secret, sep = \":\"))\nreq &lt;- httr::POST(\"https://api.idealista.com/oauth/token\",\n                  httr::add_headers(\n                    #\"Authorization\" = paste(\"Basic\", gsub(\"n\", \"\", secret)),\n                    \"Authorization\" = paste(\"Basic\", secret, sep = \" \"),\n                    \"Content-Type\" = \"application/x-www-form-urlencoded;charset=utf-8\"\n                  ),\n                  body = \"grant_type=client_credentials\"\n)\n\ntoken &lt;- paste(\"Bearer\", httr::content(req)$access_token)\n\n\nEstablish the parameters for the request link. Our goal is to obtain all ads for houses for sale in Trieste. The central point is set to the center of Trieste, with a maximum distance of 10 km. We also require a minimum size of 30 square meters for the ads Establish the parameters for the request link. Our goal is to obtain all ads for houses for sale in Trieste. The central point is set to the center of Trieste, with a maximum distance of 10 km. We also require a minimum size of 30 square meters for the ads to exclude garages.to exclude garages.\n\n\nCode\n#url user parameters\n# x = '36.71145256718129' For Malaga\n# y = '-4.4288958904720355'\nx = '45.643170'\ny = '13.790524'\nmaxItems = '10000'\ndistance = '10000'\ntype = 'homes'\nop = 'sale'\nminprice = '30001'\nmaxprice = '200000000'\nminsize = '30'\nmaxsize = '10000'\n\n\n#url fixed parameters\n# site = 'https://api.idealista.com/3.5/es/search?' For Spain\nsite = 'https://api.idealista.com/3.5/it/search?'\nloc = 'center='\n# country = '&country=es'\ncountry = '&country=it'\nmaxitems = '&maxItems=50'\npages = '&numPage='\ndist = '&distance='\nproperty = '&propertyType='\noperation = '&operation='\npricefrom = '&minPrice='\npriceto = '&maxPrice='\nmisize = '&minSize='\nmasize = '&maxSize='\nchalet = '&chalet=0'\n\n\nNow, we will send the request to Idealista. We have a monthly limit of 100(pagina = 100) for requests and one for second (Sys.sleep(1)). Each request is different only by the result page’s index.\nOnce the data are downloaded and extracted from JSON, we’ll get the lists that have to extract and put in a dataset. The problem araises becuase inside the lists are present other lists nested and not for each ad but only for someone. So that we create an empty matrix with the unique items number for ads as columns and the number of rows equal to the number of ads.\n\n\nCode\npagina = 100\n\nfor(z in 16:pagina)\n{\n  print(z)\n  \n  # prepara l'url\n  url &lt;- paste0(site, loc, x, ',', y, country, maxitems, pages, z, dist, distance,\n               property, type, operation, op, pricefrom, minprice, priceto, maxprice,\n               misize, minsize, masize, maxsize)\n  \n  # invia la richiesta a idealista\n  res &lt;- httr::POST(url, httr::add_headers(\"Authorization\" = token))\n  \n  # estrai il contenuto dal JSON \n  cont_raw &lt;- httr::content(res) \n  \n  # stop the cycle if there are no more results\n  if(length(cont_raw[[1]]) == 0) break\n\n    # NUOVO: Prendo i nomi delle colonne da tutte le liste e li unisco\n  colNames = unique(unlist(sapply(1:length(cont_raw[[1]]), function(x) cont_raw[[1]][[x]] %&gt;% names()))) %&gt;% sort()\n  \n  # Creo una matrice vuota dove imagazzinare i valori\n  m = matrix(NA, nrow = length(cont_raw[[1]]), ncol = length(colNames))\n  colnames(m) = colNames\n  for(r in 1:length(cont_raw[[1]]))\n  {\n    for(c in 1:length(cont_raw[[1]][[r]]))\n    {\n      # nel caso l'elemento della lista sia una sotto lista o df vado a spacchettarlo aggiungendo colonne\n      if(length(cont_raw[[1]][[r]][[c]])&gt;1)\n      {\n        # non si può fare in un unico caso\n        for(i in 1:length(cont_raw[[1]][[r]][[c]]))\n        {\n          # se la colonna della sottolista non è già stata aggiunta lo faccio\n          if(is.null(names(cont_raw[[1]][[r]][[c]])))\n          {\n            cont_raw[[1]][[r]][[c]] = cont_raw[[1]][[r]][[c]][[1]] \n          }\n          if(!names(cont_raw[[1]][[r]][[c]])[i] %in% colNames)\n          {\n            colNames = c(colNames, names(cont_raw[[1]][[r]][[c]])[i])\n            m = cbind(m, rep(NA,length(cont_raw[[1]]))) # aggiunta della colonna\n            colnames(m) = colNames\n          }\n        }\n        # inserisco i dati della sottolista\n        for(k in 1:length(cont_raw[[1]][[r]][[c]]))\n          m[r,names(cont_raw[[1]][[r]][[c]])[k]] = cont_raw[[1]][[r]][[c]][[k]]\n      }else{\n        tryCatch(\n          {\n            m[r,names(cont_raw[[1]][[r]][c])] = ifelse(length(cont_raw[[1]][[r]][[c]][[1]])&gt;1,\n                                                       cont_raw[[1]][[r]][[c]][[1]][[1]],\n                                                       cont_raw[[1]][[r]][[c]][[1]])\n          },\n          error = function(e) print(paste(z, r, c, e)))\n      }\n    }\n  }\n  d = m %&gt;% data.frame() %&gt;% tibble()\n  \n  # debug\n  print(c(data %&gt;% dim))\n  \n  # merge database\n  if(z == 1)\n  {\n    data = d\n  }else\n  {\n    data[setdiff(names(d), names(data))] &lt;- NA\n    d[setdiff(names(d), names(data))] &lt;- NA\n    data = bind_rows(data, d)\n  }\n  \n  Sys.sleep(1.1)\n  \n}\n\nsaveRDS(data, \"data/data_TS_24_12\")\n\n\nIn order to avoid making further requests to the site, previously collected data are retrieved and the previous code is not executed.\n\n\nCode\ndata = readRDS(file = \"data/data_TS_24_12\")\ndata"
  },
  {
    "objectID": "projects/2024-12-17_Idealista_API/index.html#clean-data",
    "href": "projects/2024-12-17_Idealista_API/index.html#clean-data",
    "title": "Idealista: case in vendita a Malaga",
    "section": "Clean Data",
    "text": "Clean Data\nEasy and fast cleaning.\n\n\nCode\n# data.frame(1:dim(data)[2],data %&gt;% names)\n# str(data)\n# pulizia dei dati\ndata$floor[data$floor == \"bj\"] = 0\n\n# indexNumeric = c(1,4,5,6,9,11,12,18,19,20,23,29,30,43)\n\ndata %&gt;% \n  mutate_at(\n    vars(\n    price,\n    priceByArea,\n    parkingSpacePrice,\n    floor,\n    priceInfo,\n    size,\n    rooms,\n    bathrooms,\n    numPhotos,\n    parkingSpace,\n    latitude,\n    longitude,\n  ),\n  as.numeric\n  ) |&gt; \n  mutate_at(\n    vars(\n      propertyType,\n      operation,\n      province,\n      municipality,\n      district,\n      country,\n      status,\n      newDevelopment,\n      detailedType,\n      highlight,\n      typology,\n      subTypology,\n    ),\n    as.factor\n  ) |&gt; \n  mutate_at(\n    vars(\n      hasLift,\n      hasPlan,\n      has3DTour,\n      has360,\n      hasStaging,\n      hasVideo,\n      showAddress,\n      newDevelopmentFinished,\n      topNewDevelopment,\n      topPlus,\n      hasParkingSpace,\n      isParkingSpaceIncludedInPrice,\n      \n    ),\n    as.logical,\n  ) |&gt; \n  mutate(\n    across(district, \\(x) str_replace_all(x, \"-\", \" - \")),\n    city_area = if_else(is.na(neighborhood), district, neighborhood),\n    label = paste0(\n      \"Title: \", title, \"\\n\",\n      \"District: \", city_area, \"\\n\",\n      \"Floor: \", floor, \"\\n\",\n      \"Size: \", size, \" m^2\\n\",\n      \"Price: \", dollar(price, prefix = \"€\", suffix = \"k\", scale = .001), \"\\n\",\n      \"Price for m^2: \", dollar(priceByArea, prefix = \"€\"), \"\\n\",\n      \"Property type: \", propertyType, \"\\n\",\n      \"Rooms: \", rooms, \"\\n\",\n      \"Bathrooms: \", bathrooms, \"\\n\",\n      \"Status: \", status, \"\\n\"\n    ),\n  ) -&gt; data\n\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `floor = .Primitive(\"as.double\")(floor)`.\nCaused by warning:\n! NA introdotti per coercizione"
  },
  {
    "objectID": "projects/2024-12-17_Idealista_API/index.html#exploratory-data-analysis",
    "href": "projects/2024-12-17_Idealista_API/index.html#exploratory-data-analysis",
    "title": "Idealista: case in vendita a Malaga",
    "section": "Exploratory data analysis",
    "text": "Exploratory data analysis\n\nPlots\n\n\nCode\ndata |&gt; \n  filter(!is.na(floor)) |&gt;\n  mutate(\n    across(city_area, \\(x) fct_na_value_to_level(x, \"NA\") |&gt; fct_lump_n(5))\n  ) |&gt; \n  summarise(\n    n = n(),\n    across(price, mean),\n    .by = c(floor, city_area)\n  ) |&gt;\n  mutate(\n    across(c(price, n), list(max = max, min = min), .names =  \"{.col}_{.fn}\"),\n    across(price, \\(x) qunif((x - min(x))/(max(x) - min(x)), min(n), max(n))),\n    .by = city_area\n  ) |&gt; \nggplot(aes(x = floor, z = price_max)) +\n  geom_line(aes(y = n)) +\n  geom_col(aes(y = price)) +\n  facet_wrap(\n    ~city_area,\n    ncol = 3,\n    scales = \"free\",\n    labeller = label_wrap_gen()\n    ) +\n  scale_y_continuous(\n    name = \"Count\",\n    sec.axis = sec_axis(trans = ~ ., name = \"Price\")\n  ) +\n  scale_x_continuous(\n    labels = ~number(., accuracy = 1)\n  ) +\n  labs(\n    y = \"\",\n    title = \"Distibution of the floor of the houses in the different districts\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nGrafico a barre del prezzo medio delle case in rapporto al piano nella quale si trovano.\n\n\nCode\np = data |&gt; \n  filter(!is.na(floor), !is.na(size)) |&gt; \n  mutate(\n    across(city_area, \\(x) fct_na_value_to_level(x, \"NA\") |&gt; fct_lump_n(8))\n  ) |&gt; \n  ggplot(aes(x = size, y = price, color = city_area,\n             group = city_area, text = label)) +\n  geom_point(\n    alpha = .7,\n    size = 1,\n  ) +\n  geom_smooth(\n    alpha = .9,\n    se = F,\n    linewidth = .5,\n    linetype = \"dashed\",\n  ) +\n  scale_y_log10(\n    labels = \\(x) dollar(x, prefix = \"€\", suffix = \"k\",\n                         scale = .001, accuracy = 1)\n  ) +\n  scale_x_continuous(\n    limits = c(15,200),\n    ) +\n  # scale_x_log10() +\n  theme(\n    legend.position = \"bottom\",\n    legend.title = element_blank(),\n  ) +\n  guides(\n    color = guide_legend(nrow = 2)\n  ) +\n  labs(\n    x = \"Size (m^2)\",\n    y = \"Price\",\n    title = \"Price of the houses in relation to the size\",\n    color = \"District\"\n  )\nggplotly(p, tooltip = \"text\") |&gt; \n  plotly::layout(\n    legend = list(\n      orientation = \"h\", \n      x = 0.5, \n      xanchor = \"center\", \n      y = -0.2\n    )\n  )\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning: Removed 30 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: The following aesthetics were dropped during statistical transformation: text\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\n\n\nMaps\nMappa del prezzo delle case nelle diverse zone della città. La mappa è interattiva, cliccando sui singoli pallini comparirà una box con ulteriori dati sulla casa.\n\n\nCode\npal = with(data, colorFactor(brewer.pal(10,\"RdYlGn\"), -priceByArea))\ndfPopup = data %&gt;% \n  mutate(popup_info = str_replace_all(label, \"\\n\", \"&lt;br&gt;\"))\nleaflet() %&gt;% \n  addTiles() %&gt;% \n  addCircleMarkers(data = dfPopup,\n                   lat = ~ latitude,\n                   lng = ~ longitude,\n                   radius = ~ 2,\n                   opacity = .7,\n                   color = ~ pal(-priceByArea),\n                   popup = ~ popup_info)\n\n\n\n\n\n\n\n\nCorrelation plot\n\n\nCode\ndata %&gt;% \n  select_if(is.numeric) %&gt;% \n  dplyr::select(\n    price,\n    size,\n    numPhotos,\n    floor,\n    rooms,\n    bathrooms,\n    ) %&gt;% \n  na.roughfix() %&gt;%  \n  cor %&gt;% \n  corrplot::corrplot(method = \"number\",\n                     hclust.method = \"ward.D2\",\n                     diag = F,\n                     type = \"upper\",\n                     order = \"hclust\",\n                     number.cex = .6)"
  }
]