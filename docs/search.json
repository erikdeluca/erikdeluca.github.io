[
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Here I will list some of the projects I have worked on.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMIPC\n\n\nInternational competition for the best portfolio for a fund plan. My aim was to find the best weights that could be used by a pension fund. The portfolio is composed by…\n\n\n\nErik De Luca\n\n\nOct 15, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Erik De Luca",
    "section": "",
    "text": "Hello! I’m Erik De Luca, an actuary with a passion for data science, always seeking new ways to transform complex numbers and data into comprehensible stories and practical solutions. With a background in statistics and actuarial techniques, I have a keen interest in quantitative finance and portfolio optimization. When not immersed in numbers, I indulge in travel, craft beer brewing, and judo. Welcome to my corner of the web!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html",
    "title": "MIPC",
    "section": "",
    "text": "I built a dataset with tickers, categories and the initial weights of the portfolio.\n\n\nCode\ndetailPortfolio =\n  tibble(\n    tickerList = c(\n      \"SPG\",      # REITS\n      \"OHI\",\n      \"CCOM.TO\",      # Commodities\n      \"DBC\",\n      \"FCX\",\n      \"KSM-F6.TA\",\n      \"0P0001MN8G.F\",      # CAT BOND\n      \"CDZ.TO\",      # dividend\n      \"NOBL\",\n      \"NSRGY\",\n      \"CNI\",\n      \"WFAFY\",\n      \"UU.L\",\n      \"KO\",\n      \"NVS\",\n      \"NVDA\", # nvidia no dividendi\n      # \"SHY\",  # short term bond -- in truth they are etfs that reproduce the trend\n      # \"VGSH\",\n      \"SPTS\",\n      \"IBGS.AS\",\n      \"6C=F\",      # cash -- I placed a Canadian dollar future to represent liquidity\n      \"XGIU.MI\"     # Inflation linked\n    ),\n    category = c(\n      rep(\"REITS\",2),\n      rep(\"Commodities\",4),\n      rep(\"CAT BOND\",1),\n      rep(\"Dividends\",9),\n      rep(\"Short term bonds\",2),\n      rep(\"Cash\",1), \n      rep(\"Inflation linked\",1) \n    ),\n    weight = c(\n      .08,\n      .06,\n      .046,\n      # comodities\n      .009,\n      .01,\n      .057,\n      .07,\n      # cat bond\n      .02,\n      # div\n      .06,\n      .02,\n      .01,\n      .017,\n      .005,\n      .005,\n      .05,\n      .023,\n      # .07,\n      # .07,\n      .05,\n      .128,\n      .15,\n      # .00,\n      .13\n    )\n  )\ndetailPortfolio |&gt; \n  summarise(\n    across(weight, sum, na.rm = TRUE),\n    .by = category\n  ) |&gt; \n  gt() |&gt; \n  fmt_percent(vars(weight), decimals = 1)\n\n\n\n\n\n\n\n\ncategory\nweight\n\n\n\n\nREITS\n14.0%\n\n\nCommodities\n12.2%\n\n\nCAT BOND\n7.0%\n\n\nDividends\n21.0%\n\n\nShort term bonds\n17.8%\n\n\nCash\n15.0%\n\n\nInflation linked\n13.0%\n\n\n\n\n\n\n\n\n\nImport data from Yahoo Finance for the last 5 years and construct the portfolio without the weights of each stock.\n\n\nCode\nstockData = lapply(detailPortfolio$tickerList,\n                     getSymbols,\n                       src = \"yahoo\",\n                       from = as.Date(\"2018-09-30\"),\n                       to = as.Date(\"2023-09-29\"),\n                       auto.assign = F\n                     )\n\n# fix tickets that have changed name during import\ndetailPortfolio$tickerList[detailPortfolio$tickerList == \"KSM-F6.TA\"] = \"KSM.F6.TA\"\ndetailPortfolio$tickerList[detailPortfolio$tickerList == \"6C=F\"] = \"X6C\"\n\n# compact the different lists\nnominalPortfolio = do.call(merge,stockData) %&gt;% \n  na.omit\n\n# the CAT BOND is volume-free\nnominalPortfolio$X0P0001MN8G.F.Volume = 1\n\nfor(i in 1:nrow(detailPortfolio))\n{\n  columnSelect = (!names(nominalPortfolio) %like% \"Volume\") & names(nominalPortfolio) %like% detailPortfolio$tickerList[i]\n  nominalPortfolio[,columnSelect] = nominalPortfolio[,columnSelect] / rep(coredata(nominalPortfolio[1,columnSelect])[1],5) \n}\n\nas_tibble(nominalPortfolio)\n\n\n\n  \n\n\n\n\n\nCode\ngrafico = highchart(type = \"stock\")\nfor(i in 1:nrow(detailPortfolio))\n  grafico = hc_add_series(grafico, \n                          Cl(nominalPortfolio[,names(nominalPortfolio) %like% detailPortfolio$tickerList[i]]),\n                          name = detailPortfolio$tickerList[i])\ngrafico\n\n\n\n\n\n\n\n\n\nI add the initial portfolio weights.\n\n\nCode\nportfolio = nominalPortfolio\n\nfor(i in 1:nrow(detailPortfolio))\n{\n  columnSelect = (!names(portfolio) %like% \"Volume\") & names(portfolio) %like% detailPortfolio$tickerList[i]\n  portfolio[,columnSelect] = coredata(nominalPortfolio[,columnSelect]) * detailPortfolio$weight[i] \n}\n\nas_tibble(portfolio)\n\n\n\n  \n\n\n\n\n\nCode\ngrafico = highchart(type = \"stock\")\nfor(i in 1:nrow(detailPortfolio))\n  \n  grafico = hc_add_series(grafico, \n                          Cl(portfolio[,names(portfolio) %like% detailPortfolio$tickerList[i]]),\n                          name = detailPortfolio$tickerList[i]) \ngrafico\n\n\n\n\n\n\n\n\n\nI create the portfolio by adding up the indices of the stocks multiplied by their weights. This gives the overall performance of the portfolio.\n\n\nCode\ncolumnNames = c(\"Open\", \"High\", \"Low\", \"Close\", \"Volume\", \"Adjusted\")\nmyPortfolio = matrix(NA, nrow(portfolio),ncol = length(columnNames))\n\nfor(i in 1:length(columnNames))\n{\n  columnSelect = names(portfolio) %like% columnNames[i]\n  myPortfolio[,i] = sapply(1:nrow(portfolio), function(r) sum(coredata(portfolio[r,columnSelect])))  \n}\n\ncolnames(myPortfolio) = paste(\"Portfolio\", columnNames, sep = \".\")\nmyPortfolio = xts(myPortfolio, order.by = index(portfolio))\n\nas_tibble(myPortfolio)\n\n\n\n  \n\n\n\n\n\nCode\np = myPortfolio %&gt;% \n  fortify() %&gt;% \n  ggplot(aes(x = Index, y = Portfolio.Open)) + \n  geom_smooth(method = \"gam\",\n              formula = formula(y ~ s(x)),\n              fill = pal[5],\n              aes(color = pal[5]),\n              alpha = .3) +\n  geom_line(color = pal[3]) +\n  geom_pointrange(aes(ymin = Portfolio.Low, \n                    ymax = Portfolio.High), \n              alpha = 0.22,\n              fill =  'turquoise1',\n              size = .1) +\n  # geom_col(aes(y = Portfolio.Volume),inherit.aes = F) +\n  xlab(\"\") +\n  ylab(\"\") +\n  scale_y_continuous(labels = function(x) scales::percent(x-1)) +\n  scale_color_manual(values = pal[5], labels = \"Prediction of portfolio trends using splines\") +\n  theme(legend.position = \"bottom\",\n        legend.title = element_blank())\n\np\n\n\n\n\n\n\n\n\n\nCode\n# ggplotly(p)"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#import-data",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#import-data",
    "title": "MIPC",
    "section": "",
    "text": "I built a dataset with tickers, categories and the initial weights of the portfolio.\n\n\nCode\ndetailPortfolio =\n  tibble(\n    tickerList = c(\n      \"SPG\",      # REITS\n      \"OHI\",\n      \"CCOM.TO\",      # Commodities\n      \"DBC\",\n      \"FCX\",\n      \"KSM-F6.TA\",\n      \"0P0001MN8G.F\",      # CAT BOND\n      \"CDZ.TO\",      # dividend\n      \"NOBL\",\n      \"NSRGY\",\n      \"CNI\",\n      \"WFAFY\",\n      \"UU.L\",\n      \"KO\",\n      \"NVS\",\n      \"NVDA\", # nvidia no dividendi\n      # \"SHY\",  # short term bond -- in truth they are etfs that reproduce the trend\n      # \"VGSH\",\n      \"SPTS\",\n      \"IBGS.AS\",\n      \"6C=F\",      # cash -- I placed a Canadian dollar future to represent liquidity\n      \"XGIU.MI\"     # Inflation linked\n    ),\n    category = c(\n      rep(\"REITS\",2),\n      rep(\"Commodities\",4),\n      rep(\"CAT BOND\",1),\n      rep(\"Dividends\",9),\n      rep(\"Short term bonds\",2),\n      rep(\"Cash\",1), \n      rep(\"Inflation linked\",1) \n    ),\n    weight = c(\n      .08,\n      .06,\n      .046,\n      # comodities\n      .009,\n      .01,\n      .057,\n      .07,\n      # cat bond\n      .02,\n      # div\n      .06,\n      .02,\n      .01,\n      .017,\n      .005,\n      .005,\n      .05,\n      .023,\n      # .07,\n      # .07,\n      .05,\n      .128,\n      .15,\n      # .00,\n      .13\n    )\n  )\ndetailPortfolio |&gt; \n  summarise(\n    across(weight, sum, na.rm = TRUE),\n    .by = category\n  ) |&gt; \n  gt() |&gt; \n  fmt_percent(vars(weight), decimals = 1)\n\n\n\n\n\n\n\n\ncategory\nweight\n\n\n\n\nREITS\n14.0%\n\n\nCommodities\n12.2%\n\n\nCAT BOND\n7.0%\n\n\nDividends\n21.0%\n\n\nShort term bonds\n17.8%\n\n\nCash\n15.0%\n\n\nInflation linked\n13.0%\n\n\n\n\n\n\n\n\n\nImport data from Yahoo Finance for the last 5 years and construct the portfolio without the weights of each stock.\n\n\nCode\nstockData = lapply(detailPortfolio$tickerList,\n                     getSymbols,\n                       src = \"yahoo\",\n                       from = as.Date(\"2018-09-30\"),\n                       to = as.Date(\"2023-09-29\"),\n                       auto.assign = F\n                     )\n\n# fix tickets that have changed name during import\ndetailPortfolio$tickerList[detailPortfolio$tickerList == \"KSM-F6.TA\"] = \"KSM.F6.TA\"\ndetailPortfolio$tickerList[detailPortfolio$tickerList == \"6C=F\"] = \"X6C\"\n\n# compact the different lists\nnominalPortfolio = do.call(merge,stockData) %&gt;% \n  na.omit\n\n# the CAT BOND is volume-free\nnominalPortfolio$X0P0001MN8G.F.Volume = 1\n\nfor(i in 1:nrow(detailPortfolio))\n{\n  columnSelect = (!names(nominalPortfolio) %like% \"Volume\") & names(nominalPortfolio) %like% detailPortfolio$tickerList[i]\n  nominalPortfolio[,columnSelect] = nominalPortfolio[,columnSelect] / rep(coredata(nominalPortfolio[1,columnSelect])[1],5) \n}\n\nas_tibble(nominalPortfolio)\n\n\n\n  \n\n\n\n\n\nCode\ngrafico = highchart(type = \"stock\")\nfor(i in 1:nrow(detailPortfolio))\n  grafico = hc_add_series(grafico, \n                          Cl(nominalPortfolio[,names(nominalPortfolio) %like% detailPortfolio$tickerList[i]]),\n                          name = detailPortfolio$tickerList[i])\ngrafico\n\n\n\n\n\n\n\n\n\nI add the initial portfolio weights.\n\n\nCode\nportfolio = nominalPortfolio\n\nfor(i in 1:nrow(detailPortfolio))\n{\n  columnSelect = (!names(portfolio) %like% \"Volume\") & names(portfolio) %like% detailPortfolio$tickerList[i]\n  portfolio[,columnSelect] = coredata(nominalPortfolio[,columnSelect]) * detailPortfolio$weight[i] \n}\n\nas_tibble(portfolio)\n\n\n\n  \n\n\n\n\n\nCode\ngrafico = highchart(type = \"stock\")\nfor(i in 1:nrow(detailPortfolio))\n  \n  grafico = hc_add_series(grafico, \n                          Cl(portfolio[,names(portfolio) %like% detailPortfolio$tickerList[i]]),\n                          name = detailPortfolio$tickerList[i]) \ngrafico\n\n\n\n\n\n\n\n\n\nI create the portfolio by adding up the indices of the stocks multiplied by their weights. This gives the overall performance of the portfolio.\n\n\nCode\ncolumnNames = c(\"Open\", \"High\", \"Low\", \"Close\", \"Volume\", \"Adjusted\")\nmyPortfolio = matrix(NA, nrow(portfolio),ncol = length(columnNames))\n\nfor(i in 1:length(columnNames))\n{\n  columnSelect = names(portfolio) %like% columnNames[i]\n  myPortfolio[,i] = sapply(1:nrow(portfolio), function(r) sum(coredata(portfolio[r,columnSelect])))  \n}\n\ncolnames(myPortfolio) = paste(\"Portfolio\", columnNames, sep = \".\")\nmyPortfolio = xts(myPortfolio, order.by = index(portfolio))\n\nas_tibble(myPortfolio)\n\n\n\n  \n\n\n\n\n\nCode\np = myPortfolio %&gt;% \n  fortify() %&gt;% \n  ggplot(aes(x = Index, y = Portfolio.Open)) + \n  geom_smooth(method = \"gam\",\n              formula = formula(y ~ s(x)),\n              fill = pal[5],\n              aes(color = pal[5]),\n              alpha = .3) +\n  geom_line(color = pal[3]) +\n  geom_pointrange(aes(ymin = Portfolio.Low, \n                    ymax = Portfolio.High), \n              alpha = 0.22,\n              fill =  'turquoise1',\n              size = .1) +\n  # geom_col(aes(y = Portfolio.Volume),inherit.aes = F) +\n  xlab(\"\") +\n  ylab(\"\") +\n  scale_y_continuous(labels = function(x) scales::percent(x-1)) +\n  scale_color_manual(values = pal[5], labels = \"Prediction of portfolio trends using splines\") +\n  theme(legend.position = \"bottom\",\n        legend.title = element_blank())\n\np\n\n\n\n\n\n\n\n\n\nCode\n# ggplotly(p)"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#decomposition-historical-series",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#decomposition-historical-series",
    "title": "MIPC",
    "section": "Decomposition historical series",
    "text": "Decomposition historical series\nI decompose the historical series to display its different components.\n\n\nCode\npfDecomposto = decompose(ts(myPortfolio$Portfolio.Open %&gt;% as.vector(),\n                            start = c(2022, 9, 29),\n                            # end = c(2023, 09, 28),\n                            frequency = 7))\n# plot(pfDecomposto)\np = tibble(Dates = seq(as.Date(\"2022-09-29\"),\n                   length = length(pfDecomposto$x),\n                   by =  \"days\"),\n       Serie = pfDecomposto$x %&gt;% coredata(),\n       Seasonal = pfDecomposto$seasonal %&gt;% coredata(),\n       Trend = pfDecomposto$trend %&gt;% coredata(),\n       Random = pfDecomposto$random %&gt;% coredata()) %&gt;% \n  gather(key = \"Type\", -Dates, value = \"y\") %&gt;% \n  ggplot(aes(x = Dates, y = y)) + \n    geom_line() +\n    facet_grid(rows = vars(Type), \n               scales = \"free_y\") +\n  ylab(\"\")  +\n  scale_x_date(date_breaks = \"1 month\",\n               date_labels = \"%b\")\n\nggplotly(p, dynamicTicks = TRUE) %&gt;%\n  # rangeslider() \n  plotly::layout(hovermode = \"x\")"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#optimisation",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#optimisation",
    "title": "MIPC",
    "section": "Optimisation",
    "text": "Optimisation\nThe current portfolio has these indices, our goal now is to optimise the portfolio to maximise the sharpe rato index, i.e. to maximise the portfolio’s return while minimising its risk.\n\n\nCode\nnominalPortfolioAdj = nominalPortfolio[,names(nominalPortfolio) %like% \"Adjusted\"] %&gt;%\n  CalculateReturns() %&gt;% \n  to.yearly.contributions() %&gt;% \n  na.omit()\n\nweight = detailPortfolio$weight\n\nnominalPortfolioAdj = nominalPortfolioAdj[,names(nominalPortfolioAdj) != \"Portfolio Return\"]\n\nmean_ret = colMeans(nominalPortfolioAdj)\n\ncov_mat = nominalPortfolio[,names(nominalPortfolio) %like% \"Adjusted\"] %&gt;%\n  CalculateReturns() %&gt;% \n  to.quarterly.contributions() %&gt;% \n  na.omit() %&gt;% \n  cov()\n\n# solo quando i volumi non sono degeneri\n\nreturn3mesi = nominalPortfolio[,!names(nominalPortfolio) %like% \"Volume\"] %&gt;%\n  CalculateReturns() %&gt;%\n  to.period.contributions(\"quarters\") %&gt;%\n  na.omit()\n\nvar3m = VaR(R = return3mesi[,names(return3mesi) %like% \"Adjusted\"],\n            method = \"historical\",\n            portfolio_method = \"component\",\n            weights = weight)\n\nport_risk = var3m$hVaR\n\ncov_mat = cov_mat[rownames(cov_mat) != \"Portfolio Return\",\n                  colnames(cov_mat) != \"Portfolio Return\"]\n\nport_returns = sum(mean_ret * weight)\n\nport_risk = sqrt(t(weight) %*% (cov_mat %*% weight))\n\nsharpe_ratio = port_returns/port_risk\n\ntibble(\"Return\" = port_returns,\n       \"Risk\" = port_risk,\n       \"VaR a 3 mesi\" = var3m$hVaR,\n       \"Sharpe ratio\" = sharpe_ratio) |&gt; \n  gt() |&gt; \n  fmt_percent(columns = 1:3) |&gt; \n  fmt_number(columns = 4, decimals = 2)\n\n\n\n\n\n\n\n\nReturn\nRisk\nVaR a 3 mesi\nSharpe ratio\n\n\n\n\n6.77%\n2.28%\n−0.96%\n2.98\n\n\n\n\n\n\n\n\nMonteCarlo Simulation\nA simulation will be carried out using the MonteCarlo method where the experiment will be repeated by randomly extracting the weights, thus finding the best portfolio combination. In this case, the experiment will be repeated 5000 times but the portfolio weights will not be completely random, they will vary around the values we preset.\n\n\nCode\nset.seed(1)\nnum_port = 5000\n\n# Creating a matrix to store the weights\nall_wts = matrix(nrow = num_port,\n                  ncol = nrow(detailPortfolio))\n\n# Creating an empty vector to store\n# Portfolio returns\nport_returns = vector('numeric', length = num_port)\n\n# Creating an empty vector to store\n# Portfolio Standard deviation\nport_risk = vector('numeric', length = num_port)\n\n# Creating an empty vector to store\n# Portfolio Sharpe Ratio\nsharpe_ratio = vector('numeric', length = num_port)\n\nfor (i in seq_along(port_returns)) {\n  precisione = 0.9\n  wts = sapply(1:length(weight), function(i) runif(1,precisione * weight[i], (2 - precisione) * weight[i]))\n  # wts = runif(length(tickerList))\n  wts = wts/sum(wts)\n  \n  # Storing weight in the matrix\n  all_wts[i,] = wts\n  \n  # Portfolio returns\n  \n  port_ret = sum(wts * mean_ret)\n  # port_ret &lt;- ((port_ret + 1)^252) - 1\n  \n  # Storing Portfolio Returns values\n  port_returns[i] = port_ret\n  \n  \n  # Creating and storing portfolio risk\n  port_sd = sqrt(t(wts) %*% (cov_mat  %*% wts))\n\n  # Più preciso ma ci mette troppo  \n  # port_sd = VaR(\n  #   R = return3mesi[, names(return3mesi) %like% \"Adjusted\"],\n  #   method = \"historical\",\n  #   portfolio_method = \"component\",\n  #   weights = wts\n  # )$hVaR\n\n  port_risk[i] = port_sd\n  \n  \n  # Creating and storing Portfolio Sharpe Ratios\n  # Assuming 0% Risk free rate\n  sr = port_ret/port_sd\n  sharpe_ratio[i] = sr\n}\n\n\n\n\nPortfolio weights\nThe weights assigned by the portfolio with the highest sharpe ratio are shown in the interactive plot below.\n\n\nCode\n# Storing the values in the table\nportfolio_values = tibble(Return = port_returns,\n                  Risk = port_risk,\n                  SharpeRatio = sharpe_ratio)\n\n\n# Converting matrix to a tibble and changing column names\nall_wts = all_wts %&gt;%\n  data.frame() %&gt;%\n  tibble\ncolnames(all_wts) = detailPortfolio$tickerList\n\n# Combing all the values together\nportfolio_values = tibble(cbind(all_wts, portfolio_values))\ncolnames(portfolio_values)[1:nrow(detailPortfolio)] = detailPortfolio$tickerList\n\nmin_var = portfolio_values[which.min(portfolio_values$Risk),]\nmax_sr = portfolio_values[which.max(portfolio_values$SharpeRatio),]\n\n# weightOLD = weight\nweight = max_sr[,1:nrow(detailPortfolio)] %&gt;% \n  as.numeric() %&gt;% \n  round(4) \n\n# con l'arrotondamento potrebbe non fare 1 e lo calibro con il primo titolo, ciò non influenzerà significativamente sullo scostamento del portafoglio\nweight[1] = weight[1] + 1 - sum(weight)\n\n# max_sr %&gt;% \n#   t() %&gt;%\n#   data.frame()\n\np = max_sr %&gt;%\n  gather(detailPortfolio$tickerList, key = Asset,\n         value = Weights) %&gt;%\n  cbind(Category = factor(detailPortfolio$category)) %&gt;% \n  mutate(Asset = Asset %&gt;%\n           as.factor() %&gt;% \n           fct_reorder(Weights),\n         Percentage = str_c(round(Weights*100,2), \"%\")) %&gt;%\n  ggplot(aes(x = Asset,\n             y = Weights,\n             fill = Category,\n             label = Percentage)) +\n  geom_bar(stat = 'identity') +\n  geom_label(nudge_y = .01, size = 3) +\n  theme_minimal() +\n  labs(x = 'Tickers',\n       y = 'Weights',\n       title = \"Weights of the portfolio tangent to the efficient frontier\") +\n  scale_y_continuous(labels = scales::percent) +\n  guides(fill = guide_legend(override.aes = aes(label = \"\"))) + \n  theme(legend.position = \"bottom\") +\n  coord_flip()\n\nggplotly(p)\n\n\n\n\n\n\n\n\nEfficient frontier\nThe graph below shows the values of the portfolios created during the optimisation process. The red dot represents the portfolio with the highest sharpe ratio.\n\n\nCode\np = portfolio_values %&gt;%\n  ggplot(aes(x = Risk, y = Return, color = SharpeRatio)) +\n  geom_point() +\n  theme_classic() +\n  scale_y_continuous(labels = scales::percent) +\n  scale_x_continuous(labels = scales::percent) +\n  labs(x = 'Annual risk',\n       y = 'Annual return',\n       title = \"Portfolio optimization and efficient frontier\") +\n  geom_point(aes(x = Risk,\n                 y = Return),\n             data = max_sr,\n             color = 'darkred') \n\nggplotly(p)"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#optimised-portfolio",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#optimised-portfolio",
    "title": "MIPC",
    "section": "Optimised portfolio",
    "text": "Optimised portfolio\n\n\nCode\n# I recreate the portfolio with the new weights\nportfolio = nominalPortfolio\n\nfor(i in 1:nrow(detailPortfolio))\n{\n  columnSelect = (!names(portfolio) %like% \"Volume\") & names(portfolio) %like% detailPortfolio$tickerList[i]\n  portfolio[,columnSelect] = coredata(nominalPortfolio[,columnSelect]) * weight[i] \n}\n\ncolumnNames = c(\"Open\", \"High\", \"Low\", \"Close\", \"Volume\", \"Adjusted\")\nmyPortfolio = matrix(NA, nrow(portfolio),ncol = length(columnNames))\n\nfor(i in 1:length(columnNames))\n{\n  columnSelect = names(portfolio) %like% columnNames[i]\n  myPortfolio[,i] = sapply(1:nrow(portfolio), function(r) sum(coredata(portfolio[r,columnSelect])))  \n}\n\ncolnames(myPortfolio) = paste(\"Portfolio\", columnNames, sep = \".\")\nmyPortfolio = xts(myPortfolio, order.by = index(portfolio)) \n\nmyPortfolio %&gt;% \n  fortify() %&gt;% \n  mutate(across(starts_with(\"Portfolio\"), \\(x) x/dplyr::first(x))) %&gt;%\n  ggplot(aes(x = Index, y = Portfolio.Open)) + \n  geom_smooth(method = \"gam\",\n              formula = formula(y ~ s(x)),\n              fill = pal[5],\n              aes(color = pal[5]),\n              alpha = .3) +\n  geom_line(color = pal[3]) +\n  geom_pointrange(aes(ymin = Portfolio.Low, \n                      ymax = Portfolio.High), \n              alpha = 0.22,\n              fill = 'turquoise1',\n              size = .1) +\n  # geom_col(aes(y = Portfolio.Volume),inherit.aes = F) +\n  xlab(\"\") +\n  ylab(\"\") +\n  scale_y_continuous(labels = function(x) scales::percent(x)) +\n  scale_color_manual(values = pal[5], labels = \"Prediction of portfolio trends using splines\") +\n  theme(legend.position = \"bottom\",\n        legend.title = element_blank())"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#var-value-at-risk",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#var-value-at-risk",
    "title": "MIPC",
    "section": "VaR: Value at Risk",
    "text": "VaR: Value at Risk\nIn the following graph, the different securities are shown with their yield, their variance on the abscissa and are coloured according to their coefficient of variation. This graph helps in the choice of initial weights (pre-optimisation) as it is easy to visualise those that perform best.\n\n\nCode\nreturnTicker = \n  map_dfc(\n    detailPortfolio$tickerList,\n    ~dailyReturn(Cl(nominalPortfolio[,names(portfolio) %like% .x]))\n  )\n\n\nNew names:\n• `daily.returns` -&gt; `daily.returns...1`\n• `daily.returns` -&gt; `daily.returns...2`\n• `daily.returns` -&gt; `daily.returns...3`\n• `daily.returns` -&gt; `daily.returns...4`\n• `daily.returns` -&gt; `daily.returns...5`\n• `daily.returns` -&gt; `daily.returns...6`\n• `daily.returns` -&gt; `daily.returns...7`\n• `daily.returns` -&gt; `daily.returns...8`\n• `daily.returns` -&gt; `daily.returns...9`\n• `daily.returns` -&gt; `daily.returns...10`\n• `daily.returns` -&gt; `daily.returns...11`\n• `daily.returns` -&gt; `daily.returns...12`\n• `daily.returns` -&gt; `daily.returns...13`\n• `daily.returns` -&gt; `daily.returns...14`\n• `daily.returns` -&gt; `daily.returns...15`\n• `daily.returns` -&gt; `daily.returns...16`\n• `daily.returns` -&gt; `daily.returns...17`\n• `daily.returns` -&gt; `daily.returns...18`\n• `daily.returns` -&gt; `daily.returns...19`\n• `daily.returns` -&gt; `daily.returns...20`\n\n\nCode\n# for(i in 1:nrow(detailPortfolio))\n#   returnTicker = cbind(returnTicker,dailyReturn(Cl(nominalPortfolio[,names(portfolio) %like% detailPortfolio$tickerList[i]])))\ncolnames(returnTicker) = detailPortfolio$tickerList\n\nreturnTickerIndici = returnTicker %&gt;% \n  as.tibble() %&gt;%\n  summarise_all(sum) %&gt;% \n  pivot_longer(1:nrow(detailPortfolio), names_to = \"Titoli\", values_to = \"Rendimento\")  %&gt;% \n  add_column(returnTicker %&gt;%\n               as.tibble() %&gt;%\n               summarise_all(sd) %&gt;%\n               pivot_longer(1:nrow(detailPortfolio), names_to = \"Titoli\", values_to = \"Varianza\") %&gt;% \n               dplyr::select(Varianza)\n             ) %&gt;% \n  mutate(Variazione = ifelse(round(Rendimento, 2) != 0,\n                             Varianza/abs(Rendimento),\n                             1)) \n\nhValMin = 1.8 # giocando con questo parametro si cambia l'asse delle y modificando la distanza dei punti estremi ai punti centrali\nhValMax = 1\n\np = returnTickerIndici %&gt;%\n  mutate(quantili = punif(Rendimento,\n                       min = hValMin * min(Rendimento), # se non metto hvalmin il min di Rendimento vale 0 e di conseguenza il log tende a meno infinito\n                       max = hValMax * max(Rendimento),\n                       log.p = T), \n    across(where(is.numeric), \\(x) round(x, 4)),\n    # across(vars(Rendimento), )\n  ) |&gt; \n  ggplot(aes(y = quantili,\n             x = Varianza,\n             color = Variazione,\n             label = Titoli,\n             z = Rendimento # serve solo per l'etichetta nel grafico interattivo\n             )) +\n  geom_point(size = 1.5) + \n  scale_color_distiller(palette = \"RdYlGn\", direction = -1) +\n  scale_x_log10(labels = scales::percent_format(accuracy = .2),\n                breaks = scales::breaks_log(n = 10, base = 10)) +\n  scale_y_continuous(labels = function(x) scales::percent(qunif(x,\n                                                                min = hValMin * min(returnTickerIndici$Rendimento),\n                                                                max = hValMax * max(returnTickerIndici$Rendimento),\n                                                                log.p = T), # associo i valori originali invertendo la funzione di ripartizione\n                                                          scale = 1),\n                     breaks = scales::pretty_breaks(10)) +\n  labs(x = \"Variation\", y = \"Return\", color = \"Coefficient \\nof variation\") +\n  theme(legend.position = \"right\", \n        legend.title.align = 0) \n\n\nggplotly(p, tooltip = c(\"z\", \"x\", \"color\", \"label\"))\n\n\n\n\n\n\n\n\nCode\nreturn3mesi = nominalPortfolio %&gt;% \n  CalculateReturns %&gt;% \n  to.period.contributions(\"quarters\")\n\n\nweight_max_sr = max_sr %&gt;% \n      t() %&gt;% \n      head(nrow(detailPortfolio)) %&gt;% \n      as.vector()\n\nVaR(return3mesi[,names(return3mesi) %like% \"Open\"],\n    method = \"historical\",\n    weights = weight_max_sr,\n    portfolio_method = \"marginal\") %&gt;% \n  pivot_longer(1:length(weight_max_sr)+1, names_to = \"Titoli\", values_to = \"VaR\") %&gt;% \n  mutate(VaR = round(VaR *100, 2)) %&gt;% \n  ggplot(aes(x = Titoli, y = VaR, fill = VaR)) +\n  geom_col() +\n  geom_hline(aes(yintercept = PortfolioVaR), color = \"orchid\") +\n  coord_flip() + \n  scale_fill_distiller(palette = \"RdYlGn\", direction = 1) +\n  theme(legend.position = \"none\") +\n  scale_x_discrete(labels = function(x) str_remove(x,\".Open\")) +\n  labs(\n    x = \"\",\n    title = \"Value at Risk of the single securities\",\n    ) +\n  scale_y_continuous(labels = scales::percent_format(),\n                     breaks = scales::pretty_breaks(8))\n\n\n\n\n\n\n\n\n\nThe following histogram shows the simulation of 1000000 samples taken from a normal of mean equal to the portfolio return on a four-monthly basis and the variance equal to the portfolio variance on a four-monthly basis.\n\n\nCode\nalpha = 0.005\n\nmedia = sapply(1:nrow(return3mesi), function(i) sum(return3mesi[i,names(nominalPortfolio) %like% \"Adjusted\"] * weight_max_sr)) %&gt;% mean(na.rm = T)\n\nvarianza = sapply(1:nrow(return3mesi), function(i) sum(return3mesi[i,names(nominalPortfolio) %like% \"Adjusted\"] * weight_max_sr)) %&gt;% sd(na.rm = T)\n\nset.seed(1)\ndf = data.frame(x = rnorm(1E6, media, varianza))\nggplot(df, aes(x, ..density..)) +\n  geom_histogram(color = \"violet\",\n                 fill = \"orchid1\",\n                 alpha = .5,\n                 bins = 30) +\n  geom_density(color = \"aquamarine\") +\n  geom_vline(xintercept = quantile(df$x, probs = alpha),\n             color = \"aquamarine2\") +\n  annotate('text',\n           x = quantile(df$x, probs = alpha),\n           y = 0.01,\n           color = \"aquamarine4\",\n           label = paste(\"VaR = \",df$x %&gt;% \n                           quantile(probs = alpha) %&gt;% \n                           round(4))) +\n  scale_y_continuous(labels = NULL) +\n  labs(\n    x = \"\",\n    y = \"\",\n    title = \"Value at Risk\",\n    )"
  },
  {
    "objectID": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#correlation",
    "href": "projects/2023-10-15_MIPC_Asset_Allocator/index.html#correlation",
    "title": "MIPC",
    "section": "Correlation",
    "text": "Correlation\nThe correlation chart is useful to see the diversification of the portfolio.The plot is interactive, so you can zoom in and out to see the details.\n\n\nCode\ncorrelazione = return3mesi[,names(return3mesi) %like% \"Adjusted\"] %&gt;% \n  na.omit %&gt;% \n  cor\n\ncolnames(correlazione) = stringr::str_remove(colnames(correlazione),\".Adjusted\")\nrownames(correlazione) = stringr::str_remove(colnames(correlazione),\".Adjusted\")\n\n\n# categories = levels(factor(detailPortfolio$category))\n# pal[which(detailPortfolio$category[detailPortfolio$tickerList == \"XGIU.MI\"] == categories)]\n\n\n# Funzione personalizzata per etichette colorate\ncolor_labels = function(labels, colors) {\n  mapply(function(label, color) {\n    as.expression(bquote(bold(.(color)(.(label)))))\n  }, labels, colors, SIMPLIFY = FALSE)\n}\n\np = correlazione %&gt;% \n  reshape2::melt() %&gt;% \n  ggplot(aes(x=Var1, y=Var2, fill = value, color = value)) + \n  geom_tile() +\n  scale_fill_distiller(name = \"Correlation\",\n                       palette = \"RdYlGn\",\n                       direction = 1) +\n  # geom_label(aes(label = round(value,2)), size =2,label.size = 0) +\n  scale_x_discrete(limits = rev(rownames(correlazione))) +\n  # scale_color_identity() +  # Imposta scale_color_identity per rimuovere il mapping del colore\n  guides(color = guide_legend(override.aes = list(color = NULL))) +  # Imposta color su NULL per nasconderlo\n  theme(axis.title = element_blank(),\n        axis.text.x = element_text(angle = 30,vjust = .95, hjust = .95))\n\nggplotly(p)\n\n\n\n\n\n\nCode\n# map_chr(detailPortfolio$tickerList,~ palette.colors(length(levels(factor(detailPortfolio$category))),\"Dark2\")[as.numeric(labels(factor(detailPortfolio$category,ordered = T)[detailPortfolio$tickerList == .x]))])\n# \n# sapply(detailPortfolio$tickerList,function(x) as.numeric(labels(factor(detailPortfolio$category,ordered = T)[detailPortfolio$tickerList == x])))"
  }
]